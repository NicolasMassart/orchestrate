// Code generated by MockGen. DO NOT EDIT.
// Source: events.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	entities "github.com/consensys/orchestrate/src/entities"
	common "github.com/ethereum/go-ethereum/common"
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
)

// MockPendingJobUseCase is a mock of PendingJobUseCase interface
type MockPendingJobUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockPendingJobUseCaseMockRecorder
}

// MockPendingJobUseCaseMockRecorder is the mock recorder for MockPendingJobUseCase
type MockPendingJobUseCaseMockRecorder struct {
	mock *MockPendingJobUseCase
}

// NewMockPendingJobUseCase creates a new mock instance
func NewMockPendingJobUseCase(ctrl *gomock.Controller) *MockPendingJobUseCase {
	mock := &MockPendingJobUseCase{ctrl: ctrl}
	mock.recorder = &MockPendingJobUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockPendingJobUseCase) EXPECT() *MockPendingJobUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockPendingJobUseCase) Execute(ctx context.Context, job *entities.Job) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, job)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute
func (mr *MockPendingJobUseCaseMockRecorder) Execute(ctx, job interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockPendingJobUseCase)(nil).Execute), ctx, job)
}

// MockChainBlockTxsUseCase is a mock of ChainBlockTxsUseCase interface
type MockChainBlockTxsUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockChainBlockTxsUseCaseMockRecorder
}

// MockChainBlockTxsUseCaseMockRecorder is the mock recorder for MockChainBlockTxsUseCase
type MockChainBlockTxsUseCaseMockRecorder struct {
	mock *MockChainBlockTxsUseCase
}

// NewMockChainBlockTxsUseCase creates a new mock instance
func NewMockChainBlockTxsUseCase(ctrl *gomock.Controller) *MockChainBlockTxsUseCase {
	mock := &MockChainBlockTxsUseCase{ctrl: ctrl}
	mock.recorder = &MockChainBlockTxsUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockChainBlockTxsUseCase) EXPECT() *MockChainBlockTxsUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockChainBlockTxsUseCase) Execute(ctx context.Context, chainUUID string, blockNumber uint64, txHashes []*common.Hash) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, chainUUID, blockNumber, txHashes)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute
func (mr *MockChainBlockTxsUseCaseMockRecorder) Execute(ctx, chainUUID, blockNumber, txHashes interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockChainBlockTxsUseCase)(nil).Execute), ctx, chainUUID, blockNumber, txHashes)
}

// MockAddChainUseCase is a mock of AddChainUseCase interface
type MockAddChainUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockAddChainUseCaseMockRecorder
}

// MockAddChainUseCaseMockRecorder is the mock recorder for MockAddChainUseCase
type MockAddChainUseCaseMockRecorder struct {
	mock *MockAddChainUseCase
}

// NewMockAddChainUseCase creates a new mock instance
func NewMockAddChainUseCase(ctrl *gomock.Controller) *MockAddChainUseCase {
	mock := &MockAddChainUseCase{ctrl: ctrl}
	mock.recorder = &MockAddChainUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockAddChainUseCase) EXPECT() *MockAddChainUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockAddChainUseCase) Execute(ctx context.Context, event *entities.Chain) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, event)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute
func (mr *MockAddChainUseCaseMockRecorder) Execute(ctx, event interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockAddChainUseCase)(nil).Execute), ctx, event)
}

// MockUpdateChainUseCase is a mock of UpdateChainUseCase interface
type MockUpdateChainUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockUpdateChainUseCaseMockRecorder
}

// MockUpdateChainUseCaseMockRecorder is the mock recorder for MockUpdateChainUseCase
type MockUpdateChainUseCaseMockRecorder struct {
	mock *MockUpdateChainUseCase
}

// NewMockUpdateChainUseCase creates a new mock instance
func NewMockUpdateChainUseCase(ctrl *gomock.Controller) *MockUpdateChainUseCase {
	mock := &MockUpdateChainUseCase{ctrl: ctrl}
	mock.recorder = &MockUpdateChainUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockUpdateChainUseCase) EXPECT() *MockUpdateChainUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockUpdateChainUseCase) Execute(ctx context.Context, event *entities.Chain) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, event)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute
func (mr *MockUpdateChainUseCaseMockRecorder) Execute(ctx, event interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockUpdateChainUseCase)(nil).Execute), ctx, event)
}

// MockDeleteChainUseCase is a mock of DeleteChainUseCase interface
type MockDeleteChainUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockDeleteChainUseCaseMockRecorder
}

// MockDeleteChainUseCaseMockRecorder is the mock recorder for MockDeleteChainUseCase
type MockDeleteChainUseCaseMockRecorder struct {
	mock *MockDeleteChainUseCase
}

// NewMockDeleteChainUseCase creates a new mock instance
func NewMockDeleteChainUseCase(ctrl *gomock.Controller) *MockDeleteChainUseCase {
	mock := &MockDeleteChainUseCase{ctrl: ctrl}
	mock.recorder = &MockDeleteChainUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockDeleteChainUseCase) EXPECT() *MockDeleteChainUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockDeleteChainUseCase) Execute(ctx context.Context, chainUUID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, chainUUID)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute
func (mr *MockDeleteChainUseCaseMockRecorder) Execute(ctx, chainUUID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockDeleteChainUseCase)(nil).Execute), ctx, chainUUID)
}

// Code generated by MockGen. DO NOT EDIT.
// Source: notifications.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	usecases "github.com/consensys/orchestrate/src/api/business/use-cases"
	entities "github.com/consensys/orchestrate/src/entities"
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
)

// MockNotificationUseCases is a mock of NotificationUseCases interface
type MockNotificationUseCases struct {
	ctrl     *gomock.Controller
	recorder *MockNotificationUseCasesMockRecorder
}

// MockNotificationUseCasesMockRecorder is the mock recorder for MockNotificationUseCases
type MockNotificationUseCasesMockRecorder struct {
	mock *MockNotificationUseCases
}

// NewMockNotificationUseCases creates a new mock instance
func NewMockNotificationUseCases(ctrl *gomock.Controller) *MockNotificationUseCases {
	mock := &MockNotificationUseCases{ctrl: ctrl}
	mock.recorder = &MockNotificationUseCasesMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockNotificationUseCases) EXPECT() *MockNotificationUseCasesMockRecorder {
	return m.recorder
}

// NotifyFailedJob mocks base method
func (m *MockNotificationUseCases) NotifyFailedJob() usecases.NotifyFailedJob {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NotifyFailedJob")
	ret0, _ := ret[0].(usecases.NotifyFailedJob)
	return ret0
}

// NotifyFailedJob indicates an expected call of NotifyFailedJob
func (mr *MockNotificationUseCasesMockRecorder) NotifyFailedJob() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NotifyFailedJob", reflect.TypeOf((*MockNotificationUseCases)(nil).NotifyFailedJob))
}

// NotifyMinedJob mocks base method
func (m *MockNotificationUseCases) NotifyMinedJob() usecases.NotifyMinedJob {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NotifyMinedJob")
	ret0, _ := ret[0].(usecases.NotifyMinedJob)
	return ret0
}

// NotifyMinedJob indicates an expected call of NotifyMinedJob
func (mr *MockNotificationUseCasesMockRecorder) NotifyMinedJob() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NotifyMinedJob", reflect.TypeOf((*MockNotificationUseCases)(nil).NotifyMinedJob))
}

// MockNotifyFailedJob is a mock of NotifyFailedJob interface
type MockNotifyFailedJob struct {
	ctrl     *gomock.Controller
	recorder *MockNotifyFailedJobMockRecorder
}

// MockNotifyFailedJobMockRecorder is the mock recorder for MockNotifyFailedJob
type MockNotifyFailedJobMockRecorder struct {
	mock *MockNotifyFailedJob
}

// NewMockNotifyFailedJob creates a new mock instance
func NewMockNotifyFailedJob(ctrl *gomock.Controller) *MockNotifyFailedJob {
	mock := &MockNotifyFailedJob{ctrl: ctrl}
	mock.recorder = &MockNotifyFailedJobMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockNotifyFailedJob) EXPECT() *MockNotifyFailedJobMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockNotifyFailedJob) Execute(ctx context.Context, job *entities.Job, errMsg string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, job, errMsg)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute
func (mr *MockNotifyFailedJobMockRecorder) Execute(ctx, job, errMsg interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockNotifyFailedJob)(nil).Execute), ctx, job, errMsg)
}

// MockNotifyMinedJob is a mock of NotifyMinedJob interface
type MockNotifyMinedJob struct {
	ctrl     *gomock.Controller
	recorder *MockNotifyMinedJobMockRecorder
}

// MockNotifyMinedJobMockRecorder is the mock recorder for MockNotifyMinedJob
type MockNotifyMinedJobMockRecorder struct {
	mock *MockNotifyMinedJob
}

// NewMockNotifyMinedJob creates a new mock instance
func NewMockNotifyMinedJob(ctrl *gomock.Controller) *MockNotifyMinedJob {
	mock := &MockNotifyMinedJob{ctrl: ctrl}
	mock.recorder = &MockNotifyMinedJobMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockNotifyMinedJob) EXPECT() *MockNotifyMinedJobMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockNotifyMinedJob) Execute(ctx context.Context, job *entities.Job) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, job)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute
func (mr *MockNotifyMinedJobMockRecorder) Execute(ctx, job interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockNotifyMinedJob)(nil).Execute), ctx, job)
}

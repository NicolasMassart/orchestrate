// Code generated by MockGen. DO NOT EDIT.
// Source: contracts.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	ethereum "github.com/consensys/orchestrate/pkg/types/ethereum"
	usecases "github.com/consensys/orchestrate/src/api/business/use-cases"
	entities "github.com/consensys/orchestrate/src/entities"
	common "github.com/ethereum/go-ethereum/common"
	hexutil "github.com/ethereum/go-ethereum/common/hexutil"
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
)

// MockContractUseCases is a mock of ContractUseCases interface
type MockContractUseCases struct {
	ctrl     *gomock.Controller
	recorder *MockContractUseCasesMockRecorder
}

// MockContractUseCasesMockRecorder is the mock recorder for MockContractUseCases
type MockContractUseCasesMockRecorder struct {
	mock *MockContractUseCases
}

// NewMockContractUseCases creates a new mock instance
func NewMockContractUseCases(ctrl *gomock.Controller) *MockContractUseCases {
	mock := &MockContractUseCases{ctrl: ctrl}
	mock.recorder = &MockContractUseCasesMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockContractUseCases) EXPECT() *MockContractUseCasesMockRecorder {
	return m.recorder
}

// GetCatalog mocks base method
func (m *MockContractUseCases) GetCatalog() usecases.GetContractsCatalogUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCatalog")
	ret0, _ := ret[0].(usecases.GetContractsCatalogUseCase)
	return ret0
}

// GetCatalog indicates an expected call of GetCatalog
func (mr *MockContractUseCasesMockRecorder) GetCatalog() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCatalog", reflect.TypeOf((*MockContractUseCases)(nil).GetCatalog))
}

// Get mocks base method
func (m *MockContractUseCases) Get() usecases.GetContractUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get")
	ret0, _ := ret[0].(usecases.GetContractUseCase)
	return ret0
}

// Get indicates an expected call of Get
func (mr *MockContractUseCasesMockRecorder) Get() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockContractUseCases)(nil).Get))
}

// GetContractEvents mocks base method
func (m *MockContractUseCases) GetContractEvents() usecases.GetContractEventsUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetContractEvents")
	ret0, _ := ret[0].(usecases.GetContractEventsUseCase)
	return ret0
}

// GetContractEvents indicates an expected call of GetContractEvents
func (mr *MockContractUseCasesMockRecorder) GetContractEvents() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetContractEvents", reflect.TypeOf((*MockContractUseCases)(nil).GetContractEvents))
}

// GetTags mocks base method
func (m *MockContractUseCases) GetTags() usecases.GetContractTagsUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTags")
	ret0, _ := ret[0].(usecases.GetContractTagsUseCase)
	return ret0
}

// GetTags indicates an expected call of GetTags
func (mr *MockContractUseCasesMockRecorder) GetTags() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTags", reflect.TypeOf((*MockContractUseCases)(nil).GetTags))
}

// SetCodeHash mocks base method
func (m *MockContractUseCases) SetCodeHash() usecases.RegisterContractDeploymentUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetCodeHash")
	ret0, _ := ret[0].(usecases.RegisterContractDeploymentUseCase)
	return ret0
}

// SetCodeHash indicates an expected call of SetCodeHash
func (mr *MockContractUseCasesMockRecorder) SetCodeHash() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetCodeHash", reflect.TypeOf((*MockContractUseCases)(nil).SetCodeHash))
}

// Register mocks base method
func (m *MockContractUseCases) Register() usecases.RegisterContractUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Register")
	ret0, _ := ret[0].(usecases.RegisterContractUseCase)
	return ret0
}

// Register indicates an expected call of Register
func (mr *MockContractUseCasesMockRecorder) Register() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Register", reflect.TypeOf((*MockContractUseCases)(nil).Register))
}

// Search mocks base method
func (m *MockContractUseCases) Search() usecases.SearchContractUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Search")
	ret0, _ := ret[0].(usecases.SearchContractUseCase)
	return ret0
}

// Search indicates an expected call of Search
func (mr *MockContractUseCasesMockRecorder) Search() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Search", reflect.TypeOf((*MockContractUseCases)(nil).Search))
}

// DecodeLog mocks base method
func (m *MockContractUseCases) DecodeLog() usecases.DecodeEventLogUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DecodeLog")
	ret0, _ := ret[0].(usecases.DecodeEventLogUseCase)
	return ret0
}

// DecodeLog indicates an expected call of DecodeLog
func (mr *MockContractUseCasesMockRecorder) DecodeLog() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DecodeLog", reflect.TypeOf((*MockContractUseCases)(nil).DecodeLog))
}

// MockGetContractsCatalogUseCase is a mock of GetContractsCatalogUseCase interface
type MockGetContractsCatalogUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockGetContractsCatalogUseCaseMockRecorder
}

// MockGetContractsCatalogUseCaseMockRecorder is the mock recorder for MockGetContractsCatalogUseCase
type MockGetContractsCatalogUseCaseMockRecorder struct {
	mock *MockGetContractsCatalogUseCase
}

// NewMockGetContractsCatalogUseCase creates a new mock instance
func NewMockGetContractsCatalogUseCase(ctrl *gomock.Controller) *MockGetContractsCatalogUseCase {
	mock := &MockGetContractsCatalogUseCase{ctrl: ctrl}
	mock.recorder = &MockGetContractsCatalogUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockGetContractsCatalogUseCase) EXPECT() *MockGetContractsCatalogUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockGetContractsCatalogUseCase) Execute(ctx context.Context) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute
func (mr *MockGetContractsCatalogUseCaseMockRecorder) Execute(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockGetContractsCatalogUseCase)(nil).Execute), ctx)
}

// MockGetContractUseCase is a mock of GetContractUseCase interface
type MockGetContractUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockGetContractUseCaseMockRecorder
}

// MockGetContractUseCaseMockRecorder is the mock recorder for MockGetContractUseCase
type MockGetContractUseCaseMockRecorder struct {
	mock *MockGetContractUseCase
}

// NewMockGetContractUseCase creates a new mock instance
func NewMockGetContractUseCase(ctrl *gomock.Controller) *MockGetContractUseCase {
	mock := &MockGetContractUseCase{ctrl: ctrl}
	mock.recorder = &MockGetContractUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockGetContractUseCase) EXPECT() *MockGetContractUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockGetContractUseCase) Execute(ctx context.Context, name, tag string) (*entities.Contract, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, name, tag)
	ret0, _ := ret[0].(*entities.Contract)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute
func (mr *MockGetContractUseCaseMockRecorder) Execute(ctx, name, tag interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockGetContractUseCase)(nil).Execute), ctx, name, tag)
}

// MockSearchContractUseCase is a mock of SearchContractUseCase interface
type MockSearchContractUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockSearchContractUseCaseMockRecorder
}

// MockSearchContractUseCaseMockRecorder is the mock recorder for MockSearchContractUseCase
type MockSearchContractUseCaseMockRecorder struct {
	mock *MockSearchContractUseCase
}

// NewMockSearchContractUseCase creates a new mock instance
func NewMockSearchContractUseCase(ctrl *gomock.Controller) *MockSearchContractUseCase {
	mock := &MockSearchContractUseCase{ctrl: ctrl}
	mock.recorder = &MockSearchContractUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockSearchContractUseCase) EXPECT() *MockSearchContractUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockSearchContractUseCase) Execute(ctx context.Context, codehash hexutil.Bytes, address *common.Address) (*entities.Contract, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, codehash, address)
	ret0, _ := ret[0].(*entities.Contract)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute
func (mr *MockSearchContractUseCaseMockRecorder) Execute(ctx, codehash, address interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockSearchContractUseCase)(nil).Execute), ctx, codehash, address)
}

// MockGetContractEventsUseCase is a mock of GetContractEventsUseCase interface
type MockGetContractEventsUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockGetContractEventsUseCaseMockRecorder
}

// MockGetContractEventsUseCaseMockRecorder is the mock recorder for MockGetContractEventsUseCase
type MockGetContractEventsUseCaseMockRecorder struct {
	mock *MockGetContractEventsUseCase
}

// NewMockGetContractEventsUseCase creates a new mock instance
func NewMockGetContractEventsUseCase(ctrl *gomock.Controller) *MockGetContractEventsUseCase {
	mock := &MockGetContractEventsUseCase{ctrl: ctrl}
	mock.recorder = &MockGetContractEventsUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockGetContractEventsUseCase) EXPECT() *MockGetContractEventsUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockGetContractEventsUseCase) Execute(ctx context.Context, chainID string, address common.Address, codeHash hexutil.Bytes, indexedInputCount uint32) (string, []string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, chainID, address, codeHash, indexedInputCount)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].([]string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// Execute indicates an expected call of Execute
func (mr *MockGetContractEventsUseCaseMockRecorder) Execute(ctx, chainID, address, codeHash, indexedInputCount interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockGetContractEventsUseCase)(nil).Execute), ctx, chainID, address, codeHash, indexedInputCount)
}

// MockGetContractTagsUseCase is a mock of GetContractTagsUseCase interface
type MockGetContractTagsUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockGetContractTagsUseCaseMockRecorder
}

// MockGetContractTagsUseCaseMockRecorder is the mock recorder for MockGetContractTagsUseCase
type MockGetContractTagsUseCaseMockRecorder struct {
	mock *MockGetContractTagsUseCase
}

// NewMockGetContractTagsUseCase creates a new mock instance
func NewMockGetContractTagsUseCase(ctrl *gomock.Controller) *MockGetContractTagsUseCase {
	mock := &MockGetContractTagsUseCase{ctrl: ctrl}
	mock.recorder = &MockGetContractTagsUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockGetContractTagsUseCase) EXPECT() *MockGetContractTagsUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockGetContractTagsUseCase) Execute(ctx context.Context, name string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, name)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute
func (mr *MockGetContractTagsUseCaseMockRecorder) Execute(ctx, name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockGetContractTagsUseCase)(nil).Execute), ctx, name)
}

// MockRegisterContractUseCase is a mock of RegisterContractUseCase interface
type MockRegisterContractUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockRegisterContractUseCaseMockRecorder
}

// MockRegisterContractUseCaseMockRecorder is the mock recorder for MockRegisterContractUseCase
type MockRegisterContractUseCaseMockRecorder struct {
	mock *MockRegisterContractUseCase
}

// NewMockRegisterContractUseCase creates a new mock instance
func NewMockRegisterContractUseCase(ctrl *gomock.Controller) *MockRegisterContractUseCase {
	mock := &MockRegisterContractUseCase{ctrl: ctrl}
	mock.recorder = &MockRegisterContractUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockRegisterContractUseCase) EXPECT() *MockRegisterContractUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockRegisterContractUseCase) Execute(ctx context.Context, contract *entities.Contract) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, contract)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute
func (mr *MockRegisterContractUseCaseMockRecorder) Execute(ctx, contract interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockRegisterContractUseCase)(nil).Execute), ctx, contract)
}

// MockRegisterContractDeploymentUseCase is a mock of RegisterContractDeploymentUseCase interface
type MockRegisterContractDeploymentUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockRegisterContractDeploymentUseCaseMockRecorder
}

// MockRegisterContractDeploymentUseCaseMockRecorder is the mock recorder for MockRegisterContractDeploymentUseCase
type MockRegisterContractDeploymentUseCaseMockRecorder struct {
	mock *MockRegisterContractDeploymentUseCase
}

// NewMockRegisterContractDeploymentUseCase creates a new mock instance
func NewMockRegisterContractDeploymentUseCase(ctrl *gomock.Controller) *MockRegisterContractDeploymentUseCase {
	mock := &MockRegisterContractDeploymentUseCase{ctrl: ctrl}
	mock.recorder = &MockRegisterContractDeploymentUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockRegisterContractDeploymentUseCase) EXPECT() *MockRegisterContractDeploymentUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockRegisterContractDeploymentUseCase) Execute(ctx context.Context, chainID string, address common.Address, codeHash hexutil.Bytes) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, chainID, address, codeHash)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute
func (mr *MockRegisterContractDeploymentUseCaseMockRecorder) Execute(ctx, chainID, address, codeHash interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockRegisterContractDeploymentUseCase)(nil).Execute), ctx, chainID, address, codeHash)
}

// MockDecodeEventLogUseCase is a mock of DecodeEventLogUseCase interface
type MockDecodeEventLogUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockDecodeEventLogUseCaseMockRecorder
}

// MockDecodeEventLogUseCaseMockRecorder is the mock recorder for MockDecodeEventLogUseCase
type MockDecodeEventLogUseCaseMockRecorder struct {
	mock *MockDecodeEventLogUseCase
}

// NewMockDecodeEventLogUseCase creates a new mock instance
func NewMockDecodeEventLogUseCase(ctrl *gomock.Controller) *MockDecodeEventLogUseCase {
	mock := &MockDecodeEventLogUseCase{ctrl: ctrl}
	mock.recorder = &MockDecodeEventLogUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockDecodeEventLogUseCase) EXPECT() *MockDecodeEventLogUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockDecodeEventLogUseCase) Execute(ctx context.Context, chainUUID string, eventLog *ethereum.Log) (*ethereum.Log, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, chainUUID, eventLog)
	ret0, _ := ret[0].(*ethereum.Log)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute
func (mr *MockDecodeEventLogUseCaseMockRecorder) Execute(ctx, chainUUID, eventLog interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockDecodeEventLogUseCase)(nil).Execute), ctx, chainUUID, eventLog)
}

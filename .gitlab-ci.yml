---

stages:
  - test
  - integration
  - e2e
  - build
  - release

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: ""
  GOPATH: ${CI_PROJECT_DIR}/.gocache
  ARTIFACT_DOWNLOAD_ATTEMPTS: 5
  RESTORE_CACHE_ATTEMPTS: 5

services:
  - docker:19.03-dind

.rules: &rules
  rules:
    - if: '$CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "master" || $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH =~ /^maintenance/' # Execute jobs when a MR for master branch
      when: on_success
      allow_failure: false
    - if: $CI_COMMIT_TAG
      when: never
    - when: manual

.go-setup: &go-setup
  image: golang:1.14
  stage: test
  before_script:
    # Set GOPATH
    - mkdir -p ${GOPATH}
    - export PATH="${PATH}:${GOPATH}/bin:${GOROOT}/bin"

.docker-setup: &docker-setup
  image: docker:19.03
  stage: build
  before_script:
    - export DOCKER_API_VERSION=1.39
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
  after_script:
    - docker logout $CI_REGISTRY

.docker-compose-e2e: &docker-compose-e2e
  stage: e2e
  before_script:
    - apk update
    - apk add make bash jq curl build-base
    - apk add --no-cache py3-pip python3
    - apk add --no-cache --virtual build-dependencies python3-dev libffi-dev openssl-dev gcc libc-dev
    - pip3 install docker-compose==1.26.0
  after_script:
    - make down
  cache:
    key: "$CI_COMMIT_REF_SLUG"
    paths:
      - build/bin/
  artifacts:
    when: always
    paths:
      - build/report/

.build-orchestrate: &build-orchestrate
  # Build orchestrate image following http://label-schema.org/rc1/ label convention convention
  - DOCKER_BUILDKIT=1 docker build
    --label org.label-schema.schema-version="1.0.0-rc1"
    --label org.label-schema.build-date=`date -u +"%Y-%m-%dT%H:%M:%SZ"`
    --label org.label-schema.name="${CI_PROJECT_NAME}"
    --label org.label-schema.version="branch"
    --label org.label-schema.url="https://docs.orchestrate.pegasys.tech"
    --label org.label-schema.vcs-url="${CI_PROJECT_URL}"
    --label org.label-schema.vcs-ref="${CI_COMMIT_SHA:0:8}"
    --label org.label-schema.vendor="PegaSys"
    -t ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA} .
  # Push images
  - docker push ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA}

.build-e2e: &build-e2e
  # Build e2e image
  - DOCKER_BUILDKIT=1 docker build
    --label org.label-schema.schema-version="1.0.0-rc1"
    --label org.label-schema.build-date=`date -u +"%Y-%m-%dT%H:%M:%SZ"`
    --label org.label-schema.name="${CI_PROJECT_NAME}/e2e"
    --label org.label-schema.version="branch"
    --label org.label-schema.url="https://docs.orchestrate.pegasys.tech"
    --label org.label-schema.vcs-url="${CI_PROJECT_URL}"
    --label org.label-schema.vcs-ref="${CI_COMMIT_SHA:0:8}"
    --label org.label-schema.vendor="PegaSys"
    -f ./tests/Dockerfile
    -t ${CI_REGISTRY_IMAGE}/e2e:${CI_COMMIT_SHORT_SHA} .
  # Push images
  - docker push ${CI_REGISTRY_IMAGE}/e2e:${CI_COMMIT_SHORT_SHA}

test:
  <<: *go-setup
  <<: *rules
  coverage: /^total:.*\s(\d+.\d+)%/
  services:
    - postgres:10.12-alpine
  variables:
    POSTGRES_PASSWORD: "postgres"
    DB_HOST: "postgres"
  script:
    - make run-coverage

integration:
  <<: *go-setup
  <<: *rules
  services:
    - docker:19.03-dind
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
    DB_HOST: "docker"
    KAFKA_HOST: "docker"
    KAFKA_URL: "docker:9092"
  script:
    - make run-integration

lint:
  <<: *go-setup
  <<: *rules
  script:
    - make lint-tools
    - make lint-ci

race:
  <<: *go-setup
  <<: *rules
  script:
    - make race

gobuild:
  <<: *go-setup
  <<: *rules
  script:
    - make gobuild
    - make gobuild-e2e
  cache:
    key: "$CI_COMMIT_REF_SLUG"
    paths:
      - build/bin/

test-e2e:
  <<: *docker-compose-e2e
  <<: *rules
  script:
    - make up-ci
    - make e2e-ci
    - exit $(docker inspect orchestrate_e2e_1 --format='{{.State.ExitCode}}')

test-multitenancy-e2e:
  <<: *docker-compose-e2e
  <<: *rules
  script:
    - mv -f .env.multitenancy .env
    - make up-ci
    - make e2e-ci
    - exit $(docker inspect orchestrate_e2e_1 --format='{{.State.ExitCode}}')

#Build orchestrate
build-orchestrate-on-branch:
  <<: *docker-setup
  script:
    - *build-orchestrate
  only:
    - /^dev\/[a-zA-Z0-9\/\-.]*$/
    - /^feature\/[a-zA-Z0-9\/\-.]*$/
    - /^fix\/[a-zA-Z0-9\/\-.]*$/
    - /^maintenance\/[a-zA-Z0-9\/\-.]*$/
    - /^release\/[a-zA-Z0-9\/\-.]*$/

build-orchestrate-on-master:
  <<: *docker-setup
  script:
    - *build-orchestrate
    - docker tag ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA} ${CI_REGISTRY_IMAGE}:latest
    - docker push ${CI_REGISTRY_IMAGE}:latest
  only:
    - master

build-orchestrate-on-tag:
  <<: *docker-setup
  script:
    # `tag` doesnt build a new image, just applies tag existing commit on master
    - docker pull ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA}
    - docker tag ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA} ${CI_REGISTRY_IMAGE}:${CI_COMMIT_TAG}
    - docker push ${CI_REGISTRY_IMAGE}:${CI_COMMIT_TAG}
  only:
    refs:
      - tags

release-orchestrate:
  image: docker:19.03
  stage: release
  before_script:
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
    - docker login -u ${DOCKER_REGISTRY_USER} -p ${DOCKER_REGISTRY_KEY} ${DOCKER_REGISTRY}
  script:
    - docker pull ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA}
    - docker tag ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA} ${DOCKER_REGISTRY}/orchestrate:${CI_COMMIT_TAG}
    - docker push ${DOCKER_REGISTRY}/orchestrate:${CI_COMMIT_TAG}
  after_script:
    - docker logout ${DOCKER_REGISTRY}
    - docker logout $CI_REGISTRY
  only:
    refs:
      - tags
  when: manual

#Build e2e
build-e2e-on-branch:
  <<: *docker-setup
  script:
    - *build-e2e
  only:
    - /^dev\/[a-zA-Z0-9\/\-.]*$/
    - /^feature\/[a-zA-Z0-9\/\-.]*$/
    - /^fix\/[a-zA-Z0-9\/\-.]*$/
    - /^maintenance\/[a-zA-Z0-9\/\-.]*$/
    - /^release\/[a-zA-Z0-9\/\-.]*$/

build-e2e-on-master:
  <<: *docker-setup
  script:
    - *build-e2e
    - docker tag ${CI_REGISTRY_IMAGE}/e2e:${CI_COMMIT_SHORT_SHA} ${CI_REGISTRY_IMAGE}/e2e:latest
    - docker push ${CI_REGISTRY_IMAGE}/e2e:latest

build-e2e-on-tag:
  <<: *docker-setup
  script:
    # `tag` doesnt build a new image, just applies tag existing commit on master
    - docker pull ${CI_REGISTRY_IMAGE}/e2e:${CI_COMMIT_SHORT_SHA}
    - docker tag ${CI_REGISTRY_IMAGE}/e2e:${CI_COMMIT_SHORT_SHA} ${CI_REGISTRY_IMAGE}/e2e:${CI_COMMIT_TAG}
    - docker push ${CI_REGISTRY_IMAGE}/e2e:${CI_COMMIT_TAG}
  only:
    refs:
      - tags

release-e2e:
  image: docker:19.03
  stage: release
  before_script:
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
    - docker login -u ${DOCKER_REGISTRY_USER} -p ${DOCKER_REGISTRY_KEY} ${DOCKER_REGISTRY}
  script:
    - docker pull ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA}
    - docker tag ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA} ${DOCKER_REGISTRY}/e2e:${CI_COMMIT_TAG}
    - docker push ${DOCKER_REGISTRY}/e2e:${CI_COMMIT_TAG}
  after_script:
    - docker logout ${DOCKER_REGISTRY}
    - docker logout $CI_REGISTRY
  only:
    refs:
      - tags
  when: manual

# Swagger API doc generation
.swagger-doc-common-scripts: &swagger-doc-common-scripts
  - swagger-combine swagger-combine.yml -o combined-schema.json
  - redoc-cli bundle combined-schema.json
  - mv redoc-static.html public/${API_DOC_VERSION}/index.html

.swagger-doc: &swagger-doc
  # template to build swagger doc
  image: node:12.16.2-stretch-slim
  stage: build
  variables:
    # default target is "latest" directory
    API_DOC_VERSION: "latest"
  before_script:
    - npm install swagger-combine@1.0.0
    - npm install redoc-cli@0.9.7
    - export PATH="$PATH:$(pwd)/node_modules/.bin"
    - mkdir -p public/${API_DOC_VERSION}
  artifacts:
    paths:
      - public
  cache:
    paths:
      - public

swagger-doc-master:
  # build swagger doc for master
  <<: *swagger-doc
  script:
    - *swagger-doc-common-scripts

    # create a redirect from home to latest
    - sed -e "s~{{LATEST_VERSION_URL}}~${CI_PAGES_URL}/latest~" public/index.html.template > public/index.html
  only:
    refs:
      - master

swagger-doc-tags:
  # build swagger doc for tagged versions
  variables:
    API_DOC_VERSION: $CI_COMMIT_TAG
    DEFAULT_API_DOC_VERSION_REDIRECT: $CI_COMMIT_TAG
  <<: *swagger-doc
  script:
    - *swagger-doc-common-scripts
    # Create a redirect from stable to latest tagged version
    - mkdir -p public/stable
    - sed -e "s~{{LATEST_VERSION_URL}}~${CI_PAGES_URL}/${CI_COMMIT_TAG}~" public/index.html.template > public/stable/index.html

    # create a redirect from home to latest
    - sed -e "s~{{LATEST_VERSION_URL}}~${CI_PAGES_URL}/latest~" public/index.html.template > public/index.html
  only:
    refs:
      - tags

#swagger-doc-branches:
#  # build swagger doc for branches, not to be published on pages, only artifact available on Gitlab
#  variables:
#    API_DOC_VERSION: $CI_COMMIT_BRANCH
#  <<: *swagger-doc
#  script:
#    - *swagger-doc-common-scripts
#    # Create a redirect from stable to latest branch version, only for testing as this artifact is not published
#    - mkdir -p public/stable
#    - sed -e "s~{{LATEST_VERSION_URL}}~${CI_PAGES_URL}/${CI_COMMIT_BRANCH}~" public/index.html.template > public/stable/index.html
#  artifacts:
#    paths:
#      - public
#    expire_in: 1 day
#  only:
#    refs:
#      - branches

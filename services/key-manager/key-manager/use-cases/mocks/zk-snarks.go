// Code generated by MockGen. DO NOT EDIT.
// Source: zk-snarks.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	gomock "github.com/golang/mock/gomock"
	usecases "github.com/ConsenSys/orchestrate/services/key-manager/key-manager/use-cases"
	reflect "reflect"
)

// MockZKSUseCases is a mock of ZKSUseCases interface
type MockZKSUseCases struct {
	ctrl     *gomock.Controller
	recorder *MockZKSUseCasesMockRecorder
}

// MockZKSUseCasesMockRecorder is the mock recorder for MockZKSUseCases
type MockZKSUseCasesMockRecorder struct {
	mock *MockZKSUseCases
}

// NewMockZKSUseCases creates a new mock instance
func NewMockZKSUseCases(ctrl *gomock.Controller) *MockZKSUseCases {
	mock := &MockZKSUseCases{ctrl: ctrl}
	mock.recorder = &MockZKSUseCasesMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockZKSUseCases) EXPECT() *MockZKSUseCasesMockRecorder {
	return m.recorder
}

// VerifySignature mocks base method
func (m *MockZKSUseCases) VerifySignature() usecases.VerifyZKSSignatureUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VerifySignature")
	ret0, _ := ret[0].(usecases.VerifyZKSSignatureUseCase)
	return ret0
}

// VerifySignature indicates an expected call of VerifySignature
func (mr *MockZKSUseCasesMockRecorder) VerifySignature() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VerifySignature", reflect.TypeOf((*MockZKSUseCases)(nil).VerifySignature))
}

// MockVerifyZKSSignatureUseCase is a mock of VerifyZKSSignatureUseCase interface
type MockVerifyZKSSignatureUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockVerifyZKSSignatureUseCaseMockRecorder
}

// MockVerifyZKSSignatureUseCaseMockRecorder is the mock recorder for MockVerifyZKSSignatureUseCase
type MockVerifyZKSSignatureUseCaseMockRecorder struct {
	mock *MockVerifyZKSSignatureUseCase
}

// NewMockVerifyZKSSignatureUseCase creates a new mock instance
func NewMockVerifyZKSSignatureUseCase(ctrl *gomock.Controller) *MockVerifyZKSSignatureUseCase {
	mock := &MockVerifyZKSSignatureUseCase{ctrl: ctrl}
	mock.recorder = &MockVerifyZKSSignatureUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockVerifyZKSSignatureUseCase) EXPECT() *MockVerifyZKSSignatureUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockVerifyZKSSignatureUseCase) Execute(ctx context.Context, address, signature, payload string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, address, signature, payload)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute
func (mr *MockVerifyZKSSignatureUseCaseMockRecorder) Execute(ctx, address, signature, payload interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockVerifyZKSSignatureUseCase)(nil).Execute), ctx, address, signature, payload)
}
